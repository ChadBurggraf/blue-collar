//-----------------------------------------------------------------------
// <copyright file="DashboardHandlerBase.cs" company="Tasty Codes">
//     Copyright (c) 2011 Chad Burggraf.
// </copyright>
//-----------------------------------------------------------------------

namespace BlueCollar.Dashboard
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO.Compression;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Web;
    using System.Web.Caching;

    /// <summary>
    /// Base <see cref="IDashboardHandler"/> implementation.
    /// </summary>
    public abstract class DashboardHandlerBase : IDashboardHandler
    {
        private static bool? canCompressResponses;
        private List<string> routeParameters;
        private int? lockTimeout;
        private bool disposed;

        /// <summary>
        /// Initializes a new instance of the DashboardHandlerBase class.
        /// </summary>
        /// <param name="repositoryFactory">The repository factory to use.</param>
        protected DashboardHandlerBase(IRepositoryFactory repositoryFactory)
        {
            if (repositoryFactory == null)
            {
                throw new ArgumentNullException("repositoryFactory", "repositoryFactory cannot be null.");
            }

            this.Helper = new HandlerHelper(this);
            this.Repository = repositoryFactory.Create();
        }

        /// <summary>
        /// Finalizes an instance of the DashboardHandlerBase class.
        /// </summary>
        ~DashboardHandlerBase()
        {
            this.Dispose(false);
        }

        /// <summary>
        /// Gets or sets the name of the application the request is being processed for.
        /// </summary>
        public string ApplicationName { get; set; }

        /// <summary>
        /// Gets or sets the URL of the root handler.
        /// </summary>
        public string HandlerUrl { get; set; }

        /// <summary>
        /// Gets or sets the handler-relative URL of the request being processed.
        /// </summary>
        public string HandlerRelativeRequestUrl { get; set; }

        /// <summary>
        /// Gets this instance's helper.
        /// </summary>
        public HandlerHelper Helper { get; private set; }

        /// <summary>
        /// Gets a value indicating whether another request can use the <see cref="IHttpHandler"/> instance.
        /// </summary>
        public virtual bool IsReusable
        {
            get { return false; }
        }

        /// <summary>
        /// Gets or sets the <see cref="QueryString"/> parsed from the current request.
        /// </summary>
        public QueryString QueryString { get; set; }

        /// <summary>
        /// Gets a collection of URL parameters that matched
        /// the route that created this instance.
        /// </summary>
        public IList<string> RouteParameters
        {
            get
            {
                return this.routeParameters ?? (this.routeParameters = new List<string>());
            }
        }

        /// <summary>
        /// Gets or sets the HTTP verb of the request being processed.
        /// </summary>
        public string Verb { get; set; }

        /// <summary>
        /// Gets the cache modes available for responses generated by this instance.
        /// </summary>
        protected abstract ResponseCacheModes CacheModes { get; }

        /// <summary>
        /// Gets the default timeout to use when acquiring record locks.
        /// </summary>
        protected int LockTimeout
        {
            get
            {
                if (this.lockTimeout == null)
                {
                    this.lockTimeout = BlueCollarSection.Section.WorkerHeartbeat * 3000;

                    if (this.lockTimeout < 1)
                    {
                        this.lockTimeout = 15000;
                    }
                }

                return this.lockTimeout.Value;
            }
        }

        /// <summary>
        /// Gets the default try count to use when acquiring record locks.
        /// </summary>
        protected int LockTryCount
        {
            get { return 10; }
        }

        /// <summary>
        /// Gets the repository to use during this request.
        /// </summary>
        protected IRepository Repository { get; private set; }

        /// <summary>
        /// Gets the content type of the response this handler generates.
        /// </summary>
        protected virtual string ResponseContentType
        {
            get { return "application/json"; }
        }

        /// <summary>
        /// Disposes of resources used by this instance.
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Enables processing of HTTP Web requests by a custom HttpHandler that implements the <see cref="IHttpHandler"/> interface.
        /// </summary>
        /// <param name="context">An <see cref="HttpContext"/> object that provides references to the intrinsic server objects (for example, Request, Response, Session, and Server) used to service HTTP requests. </param>
        public void ProcessRequest(HttpContext context)
        {
            this.ProcessRequest(new HttpContextWrapper(context));
        }

        /// <summary>
        /// Enables processing of HTTP Web requests by a custom HttpHandler that implements the <see cref="IHttpHandler"/> interface.
        /// </summary>
        /// <param name="context">An <see cref="HttpContextBase"/> object that provides references to the intrinsic server objects (for example, Request, Response, Session, and Server) used to service HTTP requests. </param>
        public void ProcessRequest(HttpContextBase context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context", "context cannot be null.");
            }

            string cacheKey = this.GetCacheKey(context);
            HandlerOutput output = context.Cache[cacheKey] as HandlerOutput;

            this.PrepareResponse(context, output);

            if (context.Response.StatusCode == 200)
            {
                if (output == null)
                {
                    try
                    {
                        output = new HandlerOutput()
                        {
                            Data = this.PerformRequest(context) ?? new byte[0],
                            Modified = DateTime.UtcNow
                        };
                    }
                    catch (HttpException ex)
                    {
                        context.Response.StatusCode = ex.GetHttpCode();
                    }

                    if (context.Response.StatusCode == 200)
                    {
                        if (BlueCollarSection.Section.Dashboard.CachingEnabled 
                            && (this.CacheModes & ResponseCacheModes.Server) == ResponseCacheModes.Server)
                        {
                            context.Cache.Add(
                                cacheKey,
                                output,
                                null,
                                Cache.NoAbsoluteExpiration,
                                Cache.NoSlidingExpiration,
                                CacheItemPriority.Low,
                                null);
                        }
                    }
                }

                if (output != null && output.Data != null && output.Data.Length > 0)
                {
                    context.Response.OutputStream.Write(output.Data, 0, output.Data.Length);
                }
            }
        }

        /// <summary>
        /// Gets the given string value as an array of bytes.
        /// </summary>
        /// <param name="value">The string value to get.</param>
        /// <returns>An array of bytes representing the string.</returns>
        protected static byte[] EncodeString(string value)
        {
            if (!string.IsNullOrEmpty(value))
            {
                return Encoding.UTF8.GetBytes(value);
            }

            return new byte[0];
        }

        /// <summary>
        /// Acquires the schedule lock for the given record ID.
        /// </summary>
        /// <param name="id">The ID of the record to obtain the lock for.</param>
        /// <returns>True if the lock was obtained, false otherwise.</returns>
        protected virtual bool AcquireScheduleLock(long id)
        {
            bool acquired = false;
            int tries = this.LockTryCount, timeout = -this.LockTimeout;

            while (!(acquired = this.Repository.AcquireScheduleLock(id, DateTime.UtcNow.AddMilliseconds(timeout))))
            {
                if (--tries > 0)
                {
                    Thread.Sleep(100);
                }
                else
                {
                    break;
                }
            }

            return acquired;
        }

        /// <summary>
        /// Acquires the worker lock for the given record ID.
        /// </summary>
        /// <param name="id">The ID of the record to obtain the lock for.</param>
        /// <returns>True if the lock was obtained, false otherwise.</returns>
        protected virtual bool AcquireWorkerLock(long id)
        {
            bool acquired = false;
            int tries = this.LockTryCount, timeout = -this.LockTimeout;

            while (!(acquired = this.Repository.AcquireWorkerLock(id, DateTime.UtcNow.AddMilliseconds(timeout))))
            {
                if (--tries > 0)
                {
                    Thread.Sleep(100);
                }
                else
                {
                    break;
                }
            }

            return acquired;
        }

        /// <summary>
        /// Acquires the working record lock for the given record ID.
        /// </summary>
        /// <param name="id">The ID of the record to obtain the lock for.</param>
        /// <returns>True if the lock was obtained, false otherwise.</returns>
        protected virtual bool AcquireWorkingLock(long id)
        {
            bool acquired = false;
            int tries = this.LockTryCount, timeout = -this.LockTimeout;

            while (!(acquired = this.Repository.AcquireWorkingLock(id, DateTime.UtcNow.AddMilliseconds(timeout))))
            {
                if (--tries > 0)
                {
                    Thread.Sleep(100);
                }
                else
                {
                    break;
                }
            }

            return acquired;
        }

        /// <summary>
        /// Throws a 400 <see cref="HttpException"/>.
        /// </summary>
        protected virtual void BadRequest()
        {
            throw new HttpException(400, "Bad Request");
        }

        /// <summary>
        /// Disposes of resources used by this instance.
        /// </summary>
        /// <param name="disposing">A value indicating whether to dispose of managed resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!this.disposed)
            {
                if (disposing)
                {
                    if (this.Repository != null)
                    {
                        this.Repository.Dispose();
                        this.Repository = null;
                    }
                }

                this.disposed = true;
            }
        }

        /// <summary>
        /// Gets the cache key to use for this instance's response.
        /// </summary>
        /// <param name="httpContext">The HTTP context to get the cache key for.</param>
        /// <returns>A cache key.</returns>
        protected virtual string GetCacheKey(HttpContextBase httpContext)
        {
            if (httpContext == null)
            {
                throw new ArgumentNullException("httpContext", "httpContext cannot be null.");
            }

            return string.Concat(
                "BlueCollar.Dashboard.",
                this.HandlerRelativeRequestUrl,
                ".",
                httpContext.Request.HttpMethod,
                ".",
                this.QueryString.ToOrderedString()).ToUpperInvariant();
        }

        /// <summary>
        /// Throws a 500 <see cref="HttpException"/>.
        /// </summary>
        protected virtual void InternalServerError()
        {
            throw new HttpException(500, "Internal Server Error");
        }

        /// <summary>
        /// Throws a 404 <see cref="HttpException"/>.
        /// </summary>
        protected virtual void NotFound()
        {
            throw new HttpException(404, "Not Found");
        }

        /// <summary>
        /// Performs the concrete request operation and returns the output
        /// as a byte array.
        /// </summary>
        /// <param name="context">The HTTP context to perform the request for.</param>
        /// <returns>The response to write.</returns>
        protected abstract byte[] PerformRequest(HttpContextBase context);

        /// <summary>
        /// Prepares an HTTP context's response.
        /// </summary>
        /// <param name="context">The HTTP context to prepare.</param>
        /// <param name="output">The cached output the response is being prepared for, if applicable.</param>
        protected virtual void PrepareResponse(HttpContextBase context, HandlerOutput output)
        {
            if (context == null)
            {
                throw new ArgumentNullException("context", "context cannot be null.");
            }

            context.Response.ContentType = this.ResponseContentType;
            context.Response.StatusCode = 200;

            if (BlueCollarSection.Section.Dashboard.CachingEnabled
                && (this.CacheModes & ResponseCacheModes.Client) == ResponseCacheModes.Client)
            {
                context.Response.Cache.SetCacheability(HttpCacheability.Public);
                context.Response.Cache.SetVaryByCustom("Accept-Encoding");

                DateTime modifiedSince = DateTime.UtcNow;
                bool check304 = false;

                if (!string.IsNullOrEmpty(context.Request.Headers["If-Modified-Since"]))
                {
                    try
                    {
                        modifiedSince = DateTime.Parse(context.Request.Headers["If-Modified-Since"], CultureInfo.InvariantCulture).ToUniversalTime();
                        check304 = true;
                    }
                    catch (FormatException)
                    {
                        context.Response.StatusCode = 400;
                    }
                }

                if (context.Response.StatusCode == 200) 
                {
                    if (check304 && (output == null || output.Modified <= modifiedSince))
                    {
                        context.Response.StatusCode = 304;
                    }

                    context.Response.Cache.SetExpires(output != null ? output.Modified.AddYears(1) : DateTime.UtcNow.AddYears(1));
                    context.Response.Cache.SetLastModified(output != null ? output.Modified : DateTime.UtcNow);
                }
            }
            else
            {
                context.Response.Cache.SetCacheability(HttpCacheability.Private);
                context.Response.Cache.SetMaxAge(new TimeSpan());
                context.Response.Cache.SetNoServerCaching();
                context.Response.Cache.SetNoStore();
            }

            if (context.Response.StatusCode == 200 && this.ShouldCompressResponse())
            {
                if (!string.IsNullOrEmpty(context.Request.Headers["accept-encoding"])
                    && (canCompressResponses == null
                    || canCompressResponses.Value))
                {
                    string[] acceptEncodingTypes = context.Request.Headers["accept-encoding"].Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                    if (acceptEncodingTypes != null)
                    {
                        try
                        {
                            if (acceptEncodingTypes.Any(e => "GZIP".Equals(e, StringComparison.OrdinalIgnoreCase)))
                            {
                                context.Response.Headers.Add("Content-Encoding", "gzip");
                                context.Response.Filter = new GZipStream(context.Response.Filter, CompressionMode.Compress);
                            }
                            else if (acceptEncodingTypes.Any(e => "DEFLATE".Equals(e, StringComparison.OrdinalIgnoreCase)))
                            {
                                context.Response.Headers.Add("Content-Encoding", "deflate");
                                context.Response.Filter = new DeflateStream(context.Response.Filter, CompressionMode.Compress);
                            }

                            canCompressResponses = true;
                        }
                        catch (PlatformNotSupportedException)
                        {
                            // Only available on IIS7 in integrated pipeline mode.
                            canCompressResponses = false;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets a value indicating whether the response should be compressed
        /// if the client accepts compression.
        /// </summary>
        /// <returns>True if the response should be compressed, false otherwise.</returns>
        protected virtual bool ShouldCompressResponse()
        {
            switch (this.ResponseContentType.ToUpperInvariant())
            {
                case "APPLICATION/JSON":
                case "TEXT/CSS":
                case "TEXT/HTML":
                case "TEXT/JAVASCRIPT":
                case "IMAGE/SVG+XML":
                    return true;
                default:
                    return false;
            }
        }
    }
}
