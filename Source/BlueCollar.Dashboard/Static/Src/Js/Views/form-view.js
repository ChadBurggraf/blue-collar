/**
 * Base form view implementation.
 *
 * @constructor
 */
var FormView = Backbone.View.extend({
    className: 'form well',
    events: {
        'submit': 'submit',
        'click button.btn-reset': 'cancel',
        'click a.btn-delete': 'del',
        'click button.btn-confirm-delete': 'confirmDelete',
        'click button.btn-cancel-delete': 'cancelDelete'
    },
    tagName: 'form',
    inputSelector: 'input, select, textarea',

    /**
     * Initialization.
     *
     * @param {Object} options Initialization options.
     */
    initialize: function(options) {
        this.options = _.extend({
            errorClassName: 'error',
            fieldSelector: '.field',
            validationSummaryMessage: 'Please correct the errors below.',
            validationSummarySelector: '.alert-error'
        }, this.options);

        this.model.bind('change', this.change, this);
        this.$el.attr('action', 'javascript:void(0);');
        this.isLoading = false;
    },

    /**
     * Handles the non-delete cancel button press.
     */
    cancel: function() {
        this.trigger('cancel', this);
    },

    /**
     * Handles the cancel delete button press.
     */
    cancelDelete: function() {
        this.$('.form-actions')
            .hide()
            .filter(':not(.form-actions-delete)')
            .fadeIn();
    },

    /**
     * Handles model change events.
     */
    change: function() {
        this.deserialize(this.getAttributes());
    },

    /**
     * Handles the confirm-delete button press.
     */
    confirmDelete: function() {
        this.trigger('delete', this, {Model: this.model, Attributes: {}, Action: 'deleted'});
    },

    /**
     * Handles an initial (pre-confirmation) delete link click.
     */
    del: function() {
        this.$('.form-actions')
            .hide()
            .filter('.form-actions-delete')
            .fadeIn();
    },

    /**
     * De-serializes the given attributes hash into this view's form fields.
     *
     * @param {Object} attributes A hash of attribute values to fill this instance with.
     * @return {FormView} This instance.
     */
    deserialize: function(attributes) {
        new FormSerializer().deserialize(this.$el, attributes, this.serializers);
        return this;
    },

    /**
     * Attempts to render an error response generated by the server.
     *
     * @param {jqXHR} response The Ajax response object indicating the error.
     * @return {boolean} True if the error was handled by this function, false otherwise.
     */
    error: function(response) {
        if (/^application\/json/i.test(response.getResponseHeader('Content-Type'))) {
            var json = null;

            try {
                json = JSON.parse(response.responseText);
            } catch (e) {
            }

            if (json && !_.isEmpty(json)) {
                this.renderErrors(json);
                return true;
            }
        }

        return false;
    },

    /**
     * Gets a jQuery object containing all of the form's fields.
     */
    findFields: function(name) {
        return this.$('input[name="' + name + '"], textarea[name="' + name + '"], select[name="' + name + '"]');
    },

    /**
     * Focuses the first element in the form.
     */
    focus: function() {
        return this;
    },

    /**
     * Gets the attributes hash to use during serialization and de-serialization.
     *
     * @return {Object} This instance's attributes hash.
     */
    getAttributes: function() {
        return !_.isUndefined(this.model.toEditJSON) ? this.model.toEditJSON() : this.model.toJSON();
    },

    /**
     * Updates the view to reflect that submitting data to or loading
     * data from the server has completed.
     */
    hideLoading: function() {
        var elements,
            el,
            data,
            i,
            n;

        function il(e) {
            var d = e.data('FormView:Loading');

            if (d) {
                e[0].disabled = d.disabled;
            }

            e.removeData('FormView:Loading');
        }

        if (this.isLoading) {
            elements = this.$(this.inputSelector);

            for (i = 0, n = elements.length; i < n; i++) {
                il($(elements[i]));
            }

            elements = this.$('button');

            for (i = 0, n = elements.length; i < n; i++) {
                il($(elements[i]));
            }

            elements = this.$('a');

            for (i = 0, n = elements.length; i < n; i++) {
                el = $(elements[i]);
                data = el.data('FormView:Loading');

                if (data) {
                    el.css('display', data.display);
                }

                el.removeData('FormView:Loading');
            }

            this.isLoading = false;
        }
    },

    /**
     * Renders the view.
     *
     * @return {FormView} This instance.
     */
    render: function() {
        var attributes = this.getAttributes(),
            actions,
            actionsDelete,
            del;

        this.$el.html(this.template(attributes));
        this.deserialize(attributes);
        this.renderErrors();

        actions = this.$('.form-actions:not(.form-actions-delete)').show();
        actionsDelete = actions.find('a.btn-delete');
        del = this.$('.form-actions-delete').hide();

        if (!this.model.get('Id')) {
            actionsDelete.remove();
            del.remove();
        }

        return this;
    },

    /**
     * Renders the given errors hash for this instance.
     *
     * @param {Object} errors A hash of error messages to render.
     * @return {FormView} This instance.
     */
    renderErrors: function(errors) {
        var summary = this.$(this.options.validationSummarySelector),
            fields = this.$(this.options.fieldSelector),
            summaryErrors = [],
            summaryList,
            prop,
            error,
            inputs,
            field,
            errorEl,
            found;

        summary.hide().html('');

        fields
            .removeClass(this.options.errorClassName)
            .find('.' + this.options.errorClassName)
            .hide();

        errors = errors || {};

        for (prop in errors) {
            if (errors.hasOwnProperty(prop)) {
                error = (errors[prop] || '').toString();

                if (error) {
                    found = false;
                    inputs = this.findFields(prop);

                    if (inputs.length > 0) {
                        field = inputs.parents(this.options.fieldSelector);
                        errorEl = field.find('.' + this.options.errorClassName);

                        if (field.length > 0 && errorEl.length > 0) {
                            field.addClass(this.options.errorClassName);
                            errorEl.text(error).show();

                            found = true;
                        }
                    }

                    if (!found) {
                        summaryErrors.push(error);
                    }
                }
            }
        }

        if (summaryErrors.length > 0) {
            summaryList = $('<ul/>');
            summaryList.append.apply(summaryList, _.map(summaryErrors, function(e) { return $('<li/>').text(e); }));

            summary
                .append($('<p/>').text(this.options.validationSummaryMessage))
                .append(summaryList)
                .show();
        }

        return this;
    },

    /**
     * Serializes the form.
     *
     * @return {Object} The serialized form attributes.
     */
    serialize: function() {
        return new FormSerializer().serialize(this.$el, this.getAttributes(), this.serializers);
    },

    /**
     * Updates the view to reflect submitting data to or loading data from
     * the server.
     */
    showLoading: function() {
        var elements,
            el,
            i,
            n;

        function il(e) {
            e.data('FormView:Loading', {disabled: e[0].disabled});
            e.attr('disabled', 'disabled');
        }

        if (!this.isLoading) {
            this.isLoading = true;
            elements = this.$(this.inputSelector);

            for (i = 0, n = elements.length; i < n; i++) {
                il($(elements[i]));
            }

            elements = this.$('button');

            for (i = 0, n = elements.length; i < n; i++) {
                il($(elements[i]));
            }

            elements = this.$('a');

            for (i = 0, n = elements.length; i < n; i++) {
                el = $(elements[i]);
                el.data('FormView:Loading', {display: el.css('display')});
                el.css('display', 'none');
            }
        }   
    },

    /**
     * Submits this form by serializing and validating the current inputs
     * If validation passes, the 'submit' event is raised. Otherwise, the
     * validation failure message(s) are rendered.
     *
     * @return {FormView} This instance.
     */
    submit: function() {
        var attributes = this.serialize(),
            errors = this.validate(attributes);

        this.renderErrors(errors);

        if (!errors) {
            this.trigger('submit', this, {Model: this.model, Attributes: attributes, Action: this.model.isNew() ? 'created' : 'updated'});
        }

        return this;
    },

    /**
     * Validates the given serialized attributes hash against this instance's validators.
     *
     * @param {Object} attributes The serialized attributes to validate.
     * @return {Object} A hash of error messages if validation failed, otherwise undefined.
     */
    validate: function(attributes) {
        var errors = {},
            prop,
            validators,
            message,
            i,
            n

        attributes = attributes || {};

        if (!_.isUndefined(this.validators) && !_.isNull(this.validators)) {
            for (prop in this.validators) {
                if (this.validators.hasOwnProperty(prop)) {
                    validators = this.validators[prop];

                    if (!_.isArray(validators)) {
                        validators = [validators];
                    }

                    for (i = 0, n = validators.length; i < n; i++) {
                        message = validators[i].validate(attributes[prop]);

                         if (message) {
                            errors[prop] = message;
                        }
                    }
                }
            }
        }

        if (!_.isEmpty(errors)) {
            return errors;
        }
    }
});