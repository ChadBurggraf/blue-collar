{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Blue Collar","body":"Blue Collar is a system for creating, managing, and executing background work in .NET applications. It is ideal for use in web applications, but can be set up for any environment where background work needs to be done.\r\n\r\nSome cool features include:\r\n\r\n  * Simple, single-assembly deployment, with no external dependencies.\r\n  * Embedded web-based management interface.\r\n  * Easily perform work for multiple applications on one machine, or perform work for one application on multiple machines, or any combination in between.\r\n  * Jobs are simple .NET objects, implementing `string Name { get; }` and `void Execute()`.\r\n  * Sensible defaults make getting up and running quickly a breeze.\r\n\r\n## The \"Just Let Me Play With It\" Setup\r\n\r\nFor the quick setup, we'll use [SQLite](http://www.sqlite.org/) as our data store. Before starting, install the appropriate [System.Data.SQLite.dll](http://system.data.sqlite.org/index.html/doc/trunk/www/downloads.wiki). If you choose **not** to install `System.Data.SQLite` in the GAC, add a reference to the DLL to your project.\r\n\r\nNext, add references to `BlueCollar.dll` and `BlueCollar.SQLiteRepository.dll` to your project. Builds are provided for both .NET 3.5 and .NET 4.0 applications. Note that data store implementations are distributed as separate assemblies, except for Microsoft SQL Server, which is included in `BlueCollar.dll`.\r\n\r\n#### Configuration\r\n\r\nOnce your references are added, you need to do a little (promise!) configuration. At a minimum, you need to tell Blue Collar the name of your application. We're also going to configure the web management dashboard by registering its handler.\r\n\r\nFirst, register the `blueCollar` configuration section under `<configSections/>`:\r\n\r\n    <configSections>\r\n      <section name=\"blueCollar\" type=\"BlueCollar.BlueCollarSection, BlueCollar\" allowDefinition=\"Everywhere\" allowLocation=\"true\" requirePermission=\"false\"/>\r\n    </configSections>\r\n\r\nNow add the `blueCollar` section as a child of the root `<configuration/>` element:\r\n\r\n    <blueCollar applicationName=\"Your Application Name\"/>\r\n\r\nReplace **Your Application Name** with a friendly application name. The system can accomodate multiple applications in the same database schema, so the application name you choose will also be used to partition this application's data.\r\n\r\nFinally, register the web management dashboard handler. By default, the handler is configured for registration at `~/collar`, so that's where we'll register it under `<system.webServer/>`:\r\n\r\n    <system.webServer>\r\n      <handlers>\r\n        <add name=\"collar\" path=\"collar\" type=\"BlueCollar.Dashboard.DashboardHandlerFactory, BlueCollar\" verb=\"*\" preCondition=\"integratedMode\" />\r\n      </handlers>\r\n    </system.webServer>\r\n\r\n#### Creating a Machine In-Process\r\n\r\nBlue Collar can create a `Machine` (our name for the service used to coordinate workers on a computer for an application) inside of the ASP.NET process. This ability is useful for low-volume scenarios, development environments, and getting up and running quickly.\r\n\r\nTo mange this in a flexible way, we'll boot up our `Machine` on application start, but only if we've configured execution by the service to be **disabled** (the default). That way, when we want to switch to service-based execution, we just have to make a quick configuration update.\r\n\r\nIf your application doesn't have one already, create a `Global.asax` file and add `using BlueCollar;` to your list of namespace registrations.\r\n\r\nNext, create a class variable called `machine`:\r\n\r\n    private static Machine machine;\r\n\r\nAnd add or update `void Application_Start()`:\r\n\r\n    void Application_Start()\r\n    {\r\n        if (!BlueCollarSection.Section.Machine.ServiceExecutionEnabled)\r\n        {\r\n            machine = new Machine();\r\n        }\r\n    }\r\n\r\nFinally, to stop work when the application is shut down, add or update `void Application_End()`:\r\n\r\n    void Application_End()\r\n    {\r\n    \tif (machine != null) \r\n    \t{\r\n            machine.Dispose();\r\n            machine = null;\r\n    \t}\r\n    }\r\n\r\n#### That's It!\r\n\r\nBuild your application and launch it in the browser. You should be able to visit `~/collar` and see that the default worker has been created and is running.\r\n\r\n## Creating Jobs\r\n\r\nTo do actual work, you need to create some jobs. Usually, this is a matter of converting an existing method invocation into a `Job` class. \r\n\r\nFor example, let's say we wanted to create a job for sending email. Suppose we currently do it by calling a static method on an `EmailService` class with the following signature:\r\n\r\n    void Send(string address, string subject, string body);\r\n\r\nIn order to do this work from a job, we might create a class as follows:\r\n\r\n    using System;\r\n    using BlueCollar;\r\n\r\n    public sealed class SendEmailJob : Job\r\n    {\r\n    \tpublic string Address { get; set; }\r\n\r\n    \tpublic string Body { get; set; }\r\n\r\n    \tpublic override string Name\r\n    \t{\r\n    \t\tget { return \"Send Email\"; }\r\n    \t}\r\n\r\n    \tpublic string Subject { get; set; }\r\n\r\n    \tpublic override void Execute()\r\n    \t{\r\n    \t\tEmailService.Send(this.Address, this.Subject, this.Body);\r\n    \t}\r\n    }\r\n\r\nAll we did was create properties for the state we needed in order to perform the work. When we enqueue the job, our object will be serialized onto the job queue with all of our custom state included. When the job is later materialized for execution, the state will be de-serialized and available for use.\r\n\r\nNow, in order to send an actual email, we'd do something similar to the following:\r\n\r\n    new SendEmailJob()\r\n    {\r\n        Address = \"example@example.com\",\r\n        Subject = \"Hello, World!\",\r\n        Body = \"This email was sent in the background, freeing up my application to be more responsive!\"\r\n    }.Enqueue();\r\n\r\n## License\r\n\r\nLicensed under the [MIT](http://www.opensource.org/licenses/mit-license.html) license.\r\n\r\nCopyright (c) 2012 Chad Burggraf.","tagline":"Background jobs and scheduled work for .NET.","google":""}