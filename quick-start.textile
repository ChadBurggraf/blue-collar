---
title: Quick Start
layout: default
---

<div class="page-header page-header-subnav">

h1. Quick Start

p. The "Let Me Just Play With It" Setup

<notextile>
<div class="subnav">
	<ul class="nav nav-pills">
		<li><a href="#configuration">Configuration</a></li>
		<li><a href="#creating-a-machine-in-process">Creating a Machine</a></li>
		<li><a href="#creating-jobs">Creating Jobs</a></li>
	</ul>
</div>
</notextile>
</div>

For the quick setup, we'll use "SQLite":http://www.sqlite.org/ as our data store. "System.Data.SQLite.dll":http://system.data.sqlite.org/index.html/doc/trunk/www/downloads.wiki is included as a dependency in the "NuGet package":http://nuget.org/packages/BlueCollar, so fire up the package manager console and execute the following:

<code class="nuget">PM> Install-Package BlueCollar</code>

NuGet will add three references to your project:

* @BlueCollar.dll@
* @BlueCollar.SQLiteRepository.dll@
* @System.Data.SQLite.dll@

<section id="configuration">

h2. Configuration

Once your references are added, you need to do a little (promise!) configuration. At a minimum, you need to tell Blue Collar the name of your application. We're also going to configure the web management dashboard by registering its handler.

First, register the @blueCollar@ configuration section under @<configSections/>@:

{% highlight xml linenos %}
<configSections>
  <section name="blueCollar" type="BlueCollar.BlueCollarSection, BlueCollar" allowDefinition="Everywhere" allowLocation="true" requirePermission="false"/>
</configSections>
{% endhighlight %}

Now add the @blueCollar@ section as a child of the root @<configuration/>@ element:

{% highlight xml linenos %}
<blueCollar applicationName="Your Application Name"/>
{% endhighlight %}

Replace *Your Application Name* with a friendly application name. The system can accomodate multiple applications in the same database schema, so the application name you choose will also be used to partition this application's data.

Finally, register the web management dashboard handler. By default, the handler is configured for registration at @~/collar@, so that's where we'll register it under @<system.webServer/>@:

{% highlight xml linenos %}
<system.webServer>
  <handlers>
    <add name="collar" path="collar" type="BlueCollar.Dashboard.DashboardHandlerFactory, BlueCollar" verb="*" preCondition="integratedMode" />
  </handlers>
</system.webServer>
{% endhighlight %}

</section>

<section id="creating-a-machine-in-process">

h2. Creating a Machine In-Process

Blue Collar can create a @Machine@ (our name for the service used to coordinate workers on a computer for an application) inside of the ASP.NET process. This ability is useful for low-volume scenarios, development environments, and getting up and running quickly.

To mange this in a flexible way, we'll boot up our @Machine@ on application start, but only if we've configured execution by the service to be *disabled* (the default). That way, when we want to switch to service-based execution, we just have to make a quick configuration update.

If your application doesn't have one already, create a @Global.asax@ file and add @using BlueCollar;@ to your list of namespace registrations.

Next, create a class variable called @machine@:

{% highlight csharp linenos %}
private static Machine machine;
{% endhighlight %}

And add or update @void Application_Start()@:

{% highlight csharp linenos %}
void Application_Start()
{
    if (!BlueCollarSection.Section.Machine.ServiceExecutionEnabled)
    {
        machine = new Machine();
    }
}
{% endhighlight %}

Finally, to stop work when the application is shut down, add or update @void Application_End()@:

{% highlight csharp linenos %}
void Application_End()
{
    if (machine != null) 
    {
        machine.Dispose();
        machine = null;
    }
}
{% endhighlight %}

h4. That's It!

Build your application and launch it in the browser. You should be able to visit @~/collar@ and see that the default worker has been created and is running.

</section>

<section id="creating-jobs">

h2. Creating Jobs

To do actual work, you need to create some jobs. Usually, this is a matter of converting an existing method invocation into a @Job@ class.

For example, let's say we wanted to create a job for sending email. Suppose we currently do it by calling a static method on an @EmailService@ class with the following signature:

{% highlight csharp linenos %}
void Send(string address, string subject, string body);
{% endhighlight %}

In order to do this work from a job, we might create a class as follows:

{% highlight csharp linenos %}
using System;
using BlueCollar;

public sealed class SendEmailJob : Job
{
    public string Address { get; set; }

    public string Body { get; set; }

    public override string Name
    {
        get { return "Send Email"; }
    }

    public string Subject { get; set; }

    public override void Execute()
    {
        EmailService.Send(this.Address, this.Subject, this.Body);
    }
}
{% endhighlight %}

All we did was create properties for the state we needed in order to perform the work. When we enqueue the job, our object will be serialized onto the job queue with all of our custom state included. When the job is later materialized for execution, the state will be de-serialized and available for use.

Now, in order to send an actual email, we'd do something similar to the following:

{% highlight csharp linenos %}
new SendEmailJob()
{
    Address = "example@example.com",
    Subject = "Hello, World!",
    Body = "This email was sent in the background, freeing up my application to be more responsive!"
}.Enqueue();
{% endhighlight %}

</section>
